
// DBOX (thread local) run global data: an instance of this object will be
// automatically generated by the RunManager (for each worker thread) by calling 
// DBOX RunAction::GenerateRun interface method. At the end of the Run, these
// (thread local) Run global intances will be merged a global intance (the one 
// that belongs to the Master RunManager), according to DBOX implementation of
// the Merge interface method.
// The appropriate (thread local) instance of this object will be available/
// obtainable in the appropriate (also thread local) EventAction Begin- and 
// End-OfEventAction interface methods where the (thread local) object will be 
// populated by data from at the end of each events.

#ifndef DBOXRUN_HH
#define DBOXRUN_HH

#include "G4Run.hh"

//#include "Hist.hh"


// forward declarations
class DBOXDetectorConstruction;
class DBOXPrimaryGeneratorAction;

class DBOXRun : public G4Run {

  // Method declaration:
  public:
    
    // CTR: 
    DBOXRun(DBOXDetectorConstruction* det, DBOXPrimaryGeneratorAction* prim);
    virtual ~DBOXRun();

    // Virtual method to be implemented to define the way of merging the underlying 
    // (thread local) Run global data structures into one global instance.
    virtual void Merge(const G4Run*);

   
    // Method to be called by the Master to compute final quantities using the 
    // its run global Run object into which all thread local run global run 
    // object instance has already been merged
    void  EndOfRunSummary();


    // Public methods (will be used by the EventAction) to add energy deposit and 
    // track length data after each events.
    //void AddEnergyDepositPerEvent(const G4double edep)   {
    //	fEdepInTarget  += edep;
    //	fEdepInTarget2 += edep*edep;
    //}

    //void AddChTrackLengthPerEvent(const G4double length) {
    //    fChargedTrackLengthInTarget  += length;
    //    fChargedTrackLengthInTarget2 += length*length;
    //}
    
    // Public method (will be used by the EventAction) to fill the energy deposit
    // histogram after each event (in the EndOfEventAction)
    //void FillEdepHistogram(const G4double edep) {
    //    if ( fIsActiveEdepHistogram ) {
    //      fEdepHistogram->Fill(edep);
    //    }
    //}

    // Public method to set properties of the energy deposit histogram: this will 
    // be invoked by the RunAction in its BeginOfRunAction method to set all 
    // properties of the histogram before the simulation starts (only if the user 
    // invoked the corresponding UI command i.e. /DBOXApp/runAction/edepHisto ).
    // A flag (fIsActiveEdepHisto) will also set to indicate that the user invoked 
    // the UI command /DBOXApp/runAction/edepHisto ... that activates the energy
    // deposit histogram. The flag stays to be 'false' otherwise (as initialised).
    //void SetEdepHisto(const G4String& filename, G4double emin, G4double emax, G4int numbins) {
    //    fIsActiveEdepHistogram = true;
    //    fEdepHistogram->ReSet(filename, emin, emax, numbins);
    //}

    //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

    void AddTrackStatus (G4int i, G4int j);
//    void AddTrackStatus (struct ParticleData);


    //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......


  // Data member declarations:
  private:
    // data members to obtain some information needed at the end for the summary
    // Note: that the PrimaryGeneratorAction is not set to the master's RunAction
    //       so it will be nullptr for the master's DBOXRun. We will set it in
    //       the Merge.
  	DBOXDetectorConstruction*    fDBOXDetector;
  	DBOXPrimaryGeneratorAction*  fDBOXPrimary;
  	//
  	// Run global data members: 
  	// - sum of the energy deposit (charged track length) in the target per event 
  	// - and sum of the squared quantity per event for rms computation
  	//G4double fEdepInTarget;
  	//G4double fEdepInTarget2;

  	//G4double fChargedTrackLengthInTarget;
  	//G4double fChargedTrackLengthInTarget2;
    
    // Energy deposit per event (in the target) histogram and a flag to indicate 
    // if this histogram was activated (requested) by the user invoking the 
    // corresponding custum /DBOXApp/runAction/edepHisto UI command
    //G4bool   fIsActiveEdepHistogram;
    //Hist*    fEdepHistogram;
    
    //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

    G4int      fStatusPrim[3];
    G4int      fStatusSec[3];

    //struct ParticleData {
    //   G4String   fParticleName;
    //   G4int      fTrackID;
    //   G4int      i;
    //  };

    //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

};

#endif
